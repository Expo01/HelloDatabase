import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Main {
    public static void main(String[] args) {

//      DbConnection.connect();
//      insert("bob", "boberton", "bob.com", "bobbo");

//        System.out.println("ALL USERS\n");
//        readAllData();

//        readSpecificRow();
//        updateFirstName();
//        deleteRow();
//        getNumberOfUsers();
    }


    // create database with DB Browser, all set to non-null field values and table titled 'allUsers'. wrote changes
// create new java project
// copy pasted database into project 'helloDatabase'
// create connection class
// import SQLite driver: project structure -> modules -> dependencies
// THIS ALL WORKS UP UNTIL HERE

// IT IS INPUTTING INTO THE TABLE
// here is what is happeneing. I create a table using the DB browser. I import the table into
// the project which creates a new version of the table it seems. when i want to
// open the table, i need to open the version existing in the project folder such as
// folder 'helloDatabase' which will be listed alongside SRC folder, but NOT in SRC folder
// this cannot be copied onto desktop or anything, it must be opened in DB browser from inside the project

    private static void insert(String firstName, String secondName, String email, String password){
        Connection con = DbConnection.connect();
        PreparedStatement ps = null; // PreparedStatement class is for an object that represents a precompiled SQL
        // statement, such that the statement and be efficiently re-used
        try{
         String sql = "INSERT INTO users(firstName, secondName, email, password) VALUES(?,?,?,?)"; // SQL statement
         ps = con.prepareStatement(sql); //SQL statement assigned to PreparedStatement object. Requires catch. why?
            // prepareStatement creates a PreparedStatement object with the String field of the created SQL statement and
            // sends it to the database, seemingly via the Connection object 'con' with instance method
         ps.setString(1, firstName); // all fields must be passed since 'users' table set up as not allowing non-null values
         ps.setString(2, secondName); // parameterIndex indicates the column the String will be assigned to in the table
         ps.setString(3, email);
         ps.setString(4, password);
         ps.execute();
         System.out.println("Data has been inserted!");
        } catch (SQLException e) {
            System.out.println(e.toString());
            // this exception may occur if null value passed as an example
        }
    }
    // how to ensure no duplicate email input if this is to be our unique identifier???

    private static void readAllData(){
        Connection con = DbConnection.connect(); // connection object
        PreparedStatement ps = null; // prepared statement for SQL command
        ResultSet rs = null; // a table of data representing a database result set usually generated by executing a statement
        // that querries a database

        try{
            String sql = "SELECT * FROM users"; // SQL command
            ps = con.prepareStatement(sql); //prepareStatement object with command parameter from Connection object instance method
            rs = ps.executeQuery(); // executes the query from the PreparedStatement and assigns the result to the ResultSet object
            while(rs.next()){ // recall that ResultSet object is a table of data, so we can loop through it
                // resultSet object appears to iterate by rows by default, such that below String objects are acquired from
                // columns as labeled.
                String firstName = rs.getString("firstName");
                String secondName = rs.getString("secondName");
                String email = rs.getString("email");
                String password = rs.getString("password");

                System.out.println("First Name: " + firstName);
                System.out.println("Second Name: " + secondName);
                System.out.println("Email: " + email);
                System.out.println("Password: " + password + "\n\n");
            }
        } catch(SQLException e){ // a catch is required in case, for instance, a requested column name does not exist
            System.out.println(e.toString());
        } finally {
            try{
                rs.close(); // closes ResultSet connection to DB instead of waiting for automatic close later
                ps.close(); // similarly closes
                con.close(); // again, closes
            } catch (SQLException e){
                System.out.println(e.toString()); // database access error exception may occur
            }
        }

    }

    private static void readSpecificRow(){
        Connection con = DbConnection.connect();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            String sql = "Select firstName from users where email  = ? "; // these commands are modifiable where different
            // values from different columns can be output based on various input
            // do get problems though if supposing a duplicate first name were used, then you don't know which user.
            // practically, must have an identifiable ID to use for querry. email works here since can't duplicate
            // unless input into table incorrectly
            ps = con.prepareStatement(sql);
            ps.setString(1, "bob.com");
            rs = ps.executeQuery();

            String firstName = rs.getString(1); // anything greater than 1 is OOB. i think this is because the
            // sql command says the get secondName and so it returns a single column of 'secondName' which we then assign a
            // string pointer to the only value present
            System.out.println(firstName);

        } catch (SQLException e){
            System.out.println(e.toString());
        } finally {
            try{
                rs.close();
                ps.close();
                con.close();
            } catch (SQLException e){
                System.out.println(e.toString());
            }

        }
    }

    private static void updateFirstName(){
        Connection con = DbConnection.connect();
        PreparedStatement ps = null;
        try{
            String sql = "UPDATE users set firstName = ? WHERE email = ? ";
            ps = con.prepareStatement(sql);
            ps.setString(1, "Bobzilla");
            ps.setString(2, "bob.com");
            ps.execute();
            System.out.println("data has been updated");
        } catch (SQLException e){
            System.out.println(e.toString());
        }
    }

    private static void deleteRow(){
        Connection con = DbConnection.connect();
        PreparedStatement ps = null;
        try{
            String sql = "delete from users WHERE email = ? ";
            ps = con.prepareStatement(sql);
            ps.setString(1,"toast.com");
            ps.execute();
            System.out.println("Data has been deleted");
        } catch (Exception e){
            System.out.println(e.toString());
        } finally {
            try{
                ps.close();
                con.close();
            } catch (SQLException e){
                e.printStackTrace(); // will tell what kind of error and which line it occured on
            }
        }
    }

    private static void getNumberOfUsers(){
        Connection con = DbConnection.connect();
        PreparedStatement ps = null;
        ResultSet rs = null;

       try {
           String sql = "select count(firstName) from users";
           ps = con.prepareStatement(sql);
           rs = ps.executeQuery();
           int size = rs.getInt(1);
           System.out.println("you have " + size + " users");
       } catch (SQLException e){
           System.out.println(e.toString());
       } finally {
           try{
               rs.close();
               ps.close();
               con.close();
           } catch (SQLException e){
               System.out.println(e.toString());
           }
       }
    }

}
























